/**
 * DarkSwap WebAssembly Bindings - Type Definitions
 * 
 * This module provides TypeScript type definitions for the DarkSwap SDK WebAssembly module.
 */

/**
 * DarkSwap SDK Configuration
 */
export interface DarkSwapConfig {
  /** Network configuration */
  network: NetworkConfig;
  /** Orderbook configuration */
  orderbook: OrderbookConfig;
  /** Trade configuration */
  trade: TradeConfig;
  /** Wallet configuration */
  wallet: WalletConfig;
}

/**
 * Network configuration
 */
export interface NetworkConfig {
  /** List of bootstrap peers to connect to */
  bootstrapPeers: string[];
  /** List of relay servers to use */
  relays: string[];
  /** Maximum number of peers to connect to */
  maxPeers: number;
  /** Whether to enable DHT for peer discovery */
  enableDht: boolean;
  /** Whether to enable mDNS for peer discovery */
  enableMdns: boolean;
  /** Whether to enable WebRTC for peer connections */
  enableWebRtc: boolean;
}

/**
 * Orderbook configuration
 */
export interface OrderbookConfig {
  /** Maximum number of orders to keep in memory */
  maxOrders: number;
  /** Order expiry time in seconds */
  orderExpiryTime: number;
  /** Whether to enable gossip for order distribution */
  enableGossip: boolean;
}

/**
 * Trade configuration
 */
export interface TradeConfig {
  /** Maximum number of trades to keep in memory */
  maxTrades: number;
  /** Trade timeout in seconds */
  tradeTimeout: number;
  /** Whether to enable automatic retry for failed trades */
  enableAutoRetry: boolean;
  /** Maximum number of retries for failed trades */
  maxRetries: number;
}

/**
 * Wallet configuration
 */
export interface WalletConfig {
  /** Wallet type */
  type: 'wasm' | 'external';
  /** Network to connect to */
  network: 'mainnet' | 'testnet' | 'regtest';
  /** Whether to enable runes support */
  enableRunes: boolean;
  /** Whether to enable alkanes support */
  enableAlkanes: boolean;
  /** External wallet provider (if type is 'external') */
  provider?: string;
}

/**
 * Order information
 */
export interface Order {
  /** Order ID (generated by the SDK) */
  id?: string;
  /** Base asset (e.g., BTC) */
  baseAsset: string;
  /** Quote asset (e.g., RUNE) */
  quoteAsset: string;
  /** Order side (buy or sell) */
  side: 'buy' | 'sell';
  /** Order type */
  type: 'limit' | 'market';
  /** Price (for limit orders) */
  price?: string;
  /** Amount of base asset */
  amount: string;
  /** Total value in quote asset */
  total?: string;
  /** Time in force */
  timeInForce?: 'GTC' | 'IOC' | 'FOK';
  /** Order expiry time (Unix timestamp) */
  expiryTime?: number;
  /** Predicate ID for conditional orders */
  predicateId?: string;
  /** Creator's peer ID */
  creatorId?: string;
  /** Creation time (Unix timestamp) */
  createdAt?: number;
}

/**
 * Trade information
 */
export interface Trade {
  /** Trade ID */
  id: string;
  /** Order ID that initiated the trade */
  orderId: string;
  /** Base asset */
  baseAsset: string;
  /** Quote asset */
  quoteAsset: string;
  /** Trade side (buy or sell) */
  side: 'buy' | 'sell';
  /** Price */
  price: string;
  /** Amount of base asset */
  amount: string;
  /** Total value in quote asset */
  total: string;
  /** Maker peer ID */
  makerId: string;
  /** Taker peer ID */
  takerId: string;
  /** Trade status */
  status: TradeStatus;
  /** Creation time (Unix timestamp) */
  createdAt: number;
  /** Completion time (Unix timestamp) */
  completedAt?: number;
  /** Error message (if status is 'failed') */
  error?: string;
}

/**
 * Trade status
 */
export type TradeStatus = 
  | 'pending'
  | 'confirming'
  | 'completed'
  | 'failed'
  | 'canceled';

/**
 * Peer information
 */
export interface Peer {
  /** Peer ID */
  id: string;
  /** Peer address */
  address: string;
  /** Whether the peer is connected */
  connected: boolean;
  /** Connection latency in milliseconds */
  latency: number;
  /** Whether the peer is a relay */
  isRelay: boolean;
  /** Supported protocols */
  protocols: string[];
  /** Connection time (Unix timestamp) */
  connectedAt: number;
}

/**
 * Wallet information
 */
export interface WalletInfo {
  /** Wallet address */
  address: string;
  /** Wallet type */
  type: string;
  /** Network */
  network: string;
  /** Whether the wallet supports runes */
  supportsRunes: boolean;
  /** Whether the wallet supports alkanes */
  supportsAlkanes: boolean;
}

/**
 * Balance information
 */
export interface Balance {
  /** Asset ID */
  asset: string;
  /** Asset name */
  name: string;
  /** Asset type */
  type: 'btc' | 'rune' | 'alkane';
  /** Balance amount */
  amount: string;
  /** Available amount (not locked in orders) */
  available: string;
  /** Locked amount (in orders) */
  locked: string;
}

/**
 * Rune information
 */
export interface RuneInfo {
  /** Rune ID */
  id: string;
  /** Rune name */
  name: string;
  /** Rune symbol */
  symbol: string;
  /** Rune decimals */
  decimals: number;
  /** Total supply */
  supply: string;
  /** Rune creator */
  creator: string;
  /** Creation time (Unix timestamp) */
  createdAt: number;
  /** Rune metadata */
  metadata?: Record<string, any>;
}

/**
 * Alkane information
 */
export interface AlkaneInfo {
  /** Alkane ID */
  id: string;
  /** Alkane name */
  name: string;
  /** Alkane symbol */
  symbol: string;
  /** Alkane decimals */
  decimals: number;
  /** Total supply */
  supply: string;
  /** Alkane creator */
  creator: string;
  /** Creation time (Unix timestamp) */
  createdAt: number;
  /** Whether the alkane is a predicate */
  isPredicate: boolean;
  /** Predicate ID (if isPredicate is true) */
  predicateId?: string;
  /** Alkane metadata */
  metadata?: Record<string, any>;
}

/**
 * Predicate information
 */
export interface PredicateInfo {
  /** Predicate ID */
  id?: string;
  /** Predicate name */
  name: string;
  /** Predicate type */
  type: 'equality' | 'time-locked' | 'multi-signature' | 'composite';
  /** Predicate description */
  description?: string;
  /** Predicate parameters */
  parameters: Record<string, any>;
  /** Creation time (Unix timestamp) */
  createdAt?: number;
  /** Creator's peer ID */
  creatorId?: string;
}

/**
 * Orderbook entry
 */
export interface OrderbookEntry {
  /** Order */
  order: Order;
  /** Peer ID of the order creator */
  peerId: string;
  /** Whether the order is local */
  isLocal: boolean;
  /** Whether the order is active */
  isActive: boolean;
  /** Remaining amount */
  remainingAmount: string;
  /** Filled amount */
  filledAmount: string;
  /** Last update time (Unix timestamp) */
  updatedAt: number;
}

/**
 * Network event
 */
export interface NetworkEvent {
  /** Event type */
  type: 'peer_connected' | 'peer_disconnected' | 'relay_connected' | 'relay_disconnected' | 'dht_event' | 'mdns_event';
  /** Event data */
  data: any;
  /** Event time (Unix timestamp) */
  timestamp: number;
}

/**
 * Order event
 */
export interface OrderEvent {
  /** Event type */
  type: 'order_created' | 'order_updated' | 'order_canceled' | 'order_expired' | 'order_filled';
  /** Order ID */
  orderId: string;
  /** Order data */
  order: Order;
  /** Event data */
  data: any;
  /** Event time (Unix timestamp) */
  timestamp: number;
}

/**
 * Trade event
 */
export interface TradeEvent {
  /** Event type */
  type: 'trade_created' | 'trade_updated' | 'trade_completed' | 'trade_failed' | 'trade_canceled';
  /** Trade ID */
  tradeId: string;
  /** Trade data */
  trade: Trade;
  /** Event data */
  data: any;
  /** Event time (Unix timestamp) */
  timestamp: number;
}

/**
 * Wallet event
 */
export interface WalletEvent {
  /** Event type */
  type: 'wallet_connected' | 'wallet_disconnected' | 'balance_updated' | 'transaction_confirmed' | 'transaction_failed';
  /** Event data */
  data: any;
  /** Event time (Unix timestamp) */
  timestamp: number;
}